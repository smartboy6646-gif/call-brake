<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Call Break Pro - 5 Rounds</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; background: #0f2027; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        .overlay { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(20, 30, 48, 0.95); padding: 25px; border-radius: 15px; text-align: center; z-index: 100; border: 2px solid #d4af37; box-shadow: 0 0 30px rgba(0,0,0,0.8); min-width: 320px; max-height: 80vh; overflow-y: auto; }
        .hidden { display: none !important; }
        button { padding: 12px 20px; background: linear-gradient(145deg, #d4af37, #b8962e); border: none; color: black; font-weight: bold; cursor: pointer; border-radius: 8px; margin: 5px; transition: 0.3s; }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(212, 175, 55, 0.4); }
        
        #bid-options { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-top: 15px; }
        #view-score-btn { position: fixed; top: 10px; right: 10px; z-index: 50; padding: 8px 15px; font-size: 12px; background: rgba(0,0,0,0.5); color: #d4af37; border: 1px solid #d4af37; }
        
        table { width: 100%; border-collapse: collapse; margin-top: 10px; color: white; font-size: 13px; }
        th, td { border: 1px solid #444; padding: 10px; text-align: center; }
        th { background: #d4af37; color: black; }
        .rank-1 { color: #ffd700; font-weight: bold; } 
        
        #notification { position: fixed; top: 20%; left: 50%; transform: translateX(-50%); background: rgba(212, 175, 55, 0.9); color: black; padding: 10px 30px; border-radius: 30px; font-weight: bold; z-index: 200; display: none; }
    </style>
</head>
<body>

    <button id="view-score-btn" onclick="toggleScoreboard()">üìä Scores</button>

    <div id="login-screen" class="overlay">
        <h2 style="color:#d4af37">‚ô† Call Break Pro</h2>
        <input type="text" id="p-name" placeholder="Name" style="padding:10px; width:80%; margin-bottom:10px; border-radius:5px; border:none;">
        <input type="text" id="r-id" placeholder="Room ID" style="padding:10px; width:80%; margin-bottom:20px; border-radius:5px; border:none;">
        <br>
        <button onclick="startGame()">Join Game</button>
    </div>

    <div id="bid-screen" class="overlay hidden">
        <h3 id="bid-title">Your Bid</h3>
        <div id="bid-options"></div>
    </div>

    <div id="score-screen" class="overlay hidden">
        <h2 style="color:#d4af37">üèÜ Scoreboard</h2>
        <div id="score-content"></div>
        <div id="game-over-controls" class="hidden">
            <h3 style="color:#ff4444">Game Over!</h3>
            <button onclick="resetWholeGame()">Play Again</button>
        </div>
        <button id="close-score-btn" onclick="toggleScoreboard()" style="background:#555; color:white;">Close</button>
        <button id="host-next-btn" class="hidden" onclick="nextRound()">Next Round</button>
    </div>

    <div id="notification"></div>
    <div id="game-container"></div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getDatabase, ref, set, onValue, update, get } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDKKAxKTFJcMDmj6j21nKHwlSpwAxsw57k",
            authDomain: "call-breke.firebaseapp.com",
            databaseURL: "https://call-breke-default-rtdb.firebaseio.com",
            projectId: "call-breke",
        };
        
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        let game, roomId, myId, mySeat, gameData;
        const rankVal = {'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'10':10,'J':11,'Q':12,'K':13,'A':14};
        
        class MainScene extends Phaser.Scene {
            constructor() { super('MainScene'); }

            create() {
                this.add.rectangle(0, 0, this.scale.width, this.scale.height, 0x163020).setOrigin(0);
                
                this.roundText = this.add.text(20, 20, 'Round: 1 / 5', { 
                    fontSize: '18px', 
                    fontFamily: 'Segoe UI',
                    color: '#d4af37', 
                    fontStyle: 'bold',
                    backgroundColor: '#00000088',
                    padding: { x: 10, y: 5 }
                }).setScrollFactor(0).setDepth(100);

                this.createCardTextures();
                this.playerTexts = [];
                const w = this.scale.width, h = this.scale.height;
                const positions = [{x: w/2, y: h - 110}, {x: 60, y: h/2}, {x: w/2, y: 60}, {x: w - 60, y: h/2}];

                positions.forEach((p, i) => {
                    this.playerTexts.push(this.add.text(p.x, p.y, '', { fontSize: '14px', backgroundColor: '#00000088', padding: 5, align: 'center' }).setOrigin(0.5));
                });

                onValue(ref(db, 'rooms/' + roomId), (snap) => {
                    const val = snap.val();
                    if(val) { gameData = val; this.updateUI(val); }
                });
            }

            createCardTextures() {
                ['S','H','D','C'].forEach(suit => {
                    ['2','3','4','5','6','7','8','9','10','J','Q','K','A'].forEach(rank => {
                        const key = `card_${suit}_${rank}`;
                        if (this.textures.exists(key)) return;
                        const canvas = this.textures.createCanvas(key, 80, 110);
                        const ctx = canvas.getContext();
                        ctx.fillStyle = 'white'; ctx.beginPath(); this.roundRect(ctx,0,0,80,110,8); ctx.fill();
                        ctx.strokeStyle = '#333'; ctx.lineWidth = 1; ctx.stroke();
                        ctx.fillStyle = (suit==='H'||suit==='D')?'#d00':'#000';
                        ctx.font = 'bold 16px Arial'; ctx.fillText(rank, 5, 20);
                        ctx.font = '24px Arial'; ctx.fillText({S:'‚ô†',H:'‚ô•',D:'‚ô¶',C:'‚ô£'}[suit], 30, 65);
                        canvas.refresh();
                    });
                });
                const back = this.textures.createCanvas('card_back', 80, 110);
                const btx = back.getContext();
                btx.fillStyle = '#2c3e50'; btx.beginPath(); this.roundRect(btx,0,0,80,110,8); btx.fill();
                btx.strokeStyle = '#d4af37'; btx.lineWidth = 4; btx.stroke();
                back.refresh();
            }

            roundRect(ctx, x, y, w, h, r) {
                ctx.moveTo(x+r, y); ctx.arcTo(x+w, y, x+w, y+h, r); ctx.arcTo(x+w, y+h, x, y+h, r); ctx.arcTo(x, y+h, x, y, r); ctx.arcTo(x, y, x+w, y, r); ctx.closePath();
            }

            updateUI(data) {
                if(this.roundText) {
                    this.roundText.setText(`Round: ${data.currentRound || 1} / 5`);
                }

                this.children.list.filter(c => c.getData('isCard')).forEach(c => c.destroy());
                if(mySeat === undefined) mySeat = data.players.findIndex(p => p.id === myId);

                data.players.forEach((p, i) => {
                    const rel = (i - mySeat + 4) % 4;
                    const isTurn = data.turn === i && data.status === 'playing';
                    this.playerTexts[rel].setText(`${p.name}\n${isTurn ? '‚≠ê ' : ''}Bid: ${p.bid} | Won: ${p.tricks}`);
                    this.playerTexts[rel].setStyle({ color: isTurn ? '#d4af37' : '#fff' });
                });

                if(data.status === 'bidding' && data.turn === mySeat) {
                    document.getElementById('bid-screen').classList.remove('hidden');
                } else {
                    document.getElementById('bid-screen').classList.add('hidden');
                }

                const hand = data.players[mySeat].hand || [];
                hand.sort((a,b) => (a.s === b.s) ? rankVal[a.r] - rankVal[b.r] : a.s.localeCompare(b.s));
                hand.forEach((card, i) => {
                    const x = (this.scale.width/2 - (hand.length*20)/2) + (i*25);
                    const cS = this.add.sprite(x, this.scale.height - 60, `card_${card.s}_${card.r}`).setInteractive().setData('isCard', true);
                    const isValid = this.isMoveValid(card, hand, data.currentTrick || [], data.leadSuit);
                    if(data.turn !== mySeat || !isValid) cS.setAlpha(0.5);
                    cS.on('pointerdown', () => { if(data.turn === mySeat && isValid) this.playCard(card, i, data); });
                });

                (data.currentTrick || []).forEach(t => {
                    const rel = (t.pIdx - mySeat + 4) % 4;
                    const pos = [{x:this.scale.width/2, y:this.scale.height/2+50}, {x:this.scale.width/2-70, y:this.scale.height/2}, {x:this.scale.width/2, y:this.scale.height/2-50}, {x:this.scale.width/2+70, y:this.scale.height/2}][rel];
                    this.add.sprite(pos.x, pos.y, `card_${t.card.s}_${t.card.r}`).setScale(0.8).setData('isCard', true);
                });

                if(data.status === 'round_end') showScoreboard(data);
            }

            isMoveValid(card, hand, trick, lead) {
                if(!lead || trick.length === 0) return true;
                const hasLead = hand.some(c => c.s === lead);
                const hasSpade = hand.some(c => c.s === 'S');
                
                let winCard = trick[0].card;
                trick.forEach(t => {
                    const c = t.card;
                    if((c.s==='S' && winCard.s!=='S') || (c.s==='S' && winCard.s==='S' && rankVal[c.r]>rankVal[winCard.r]) || (c.s===lead && winCard.s===lead && rankVal[c.r]>rankVal[winCard.r])) winCard = c;
                });

                if(hasLead) {
                    if(card.s !== lead) return false;
                    const betterLead = hand.filter(c => c.s === lead && rankVal[c.r] > rankVal[winCard.r]);
                    if(winCard.s === lead && betterLead.length > 0) return rankVal[card.r] > rankVal[winCard.r];
                    return true;
                }
                if(hasSpade) {
                    if(card.s === 'S') {
                        if(winCard.s === 'S') {
                            const betterSpade = hand.filter(c => c.s === 'S' && rankVal[c.r] > rankVal[winCard.r]);
                            if(betterSpade.length > 0) return rankVal[card.r] > rankVal[winCard.r];
                        }
                        return true;
                    }
                    return false;
                }
                return true;
            }

            playCard(card, idx, data) {
                const p = [...data.players];
                p[mySeat].hand.splice(idx, 1);
                const newTrick = [...(data.currentTrick || []), {pIdx: mySeat, card: card}];
                update(ref(db, 'rooms/'+roomId), { players: p, currentTrick: newTrick, leadSuit: data.leadSuit || card.s, turn: (mySeat+1)%4 });
                
                if(newTrick.length === 4) {
                    setTimeout(() => this.resolveTrick(newTrick, p), 1000);
                }
            }

            resolveTrick(trick, players) {
                let winIdx = 0; let best = trick[0].card; const lead = trick[0].card.s;
                trick.forEach((t, i) => {
                    const c = t.card;
                    if((c.s==='S' && best.s!=='S') || (c.s==='S' && best.s==='S' && rankVal[c.r]>rankVal[best.r]) || (c.s===lead && best.s===lead && rankVal[c.r]>rankVal[best.r])) { best = c; winIdx = i; }
                });
                
                const winnerSeat = trick[winIdx].pIdx;
                players[winnerSeat].tricks++;

                const rel = (winnerSeat - mySeat + 4) % 4;
                const dest = [{x:this.scale.width/2, y:this.scale.height}, {x:0, y:this.scale.height/2}, {x:this.scale.width/2, y:0}, {x:this.scale.width, y:this.scale.height/2}][rel];
                
                this.children.list.filter(c => c.getData('isCard') && !c.input).forEach(c => {
                    this.tweens.add({ targets: c, x: dest.x, y: dest.y, alpha: 0, duration: 500 });
                });

                setTimeout(() => {
                    if(players[0].hand.length === 0) {
                        const roundNum = (gameData.currentRound || 1);
                        players.forEach(pl => {
                            const pts = (pl.tricks >= pl.bid) ? pl.bid + (pl.tricks-pl.bid)*0.1 : -pl.bid;
                            if(!pl.roundScores) pl.roundScores = {};
                            pl.roundScores[roundNum] = parseFloat(pts.toFixed(1));
                            pl.totalScore = Object.values(pl.roundScores).reduce((a,b) => a+b, 0);
                        });
                        update(ref(db, 'rooms/'+roomId), { players, status: 'round_end', currentTrick: [], currentRound: roundNum });
                    } else {
                        update(ref(db, 'rooms/'+roomId), { players, currentTrick: [], turn: winnerSeat, leadSuit: '' });
                    }
                }, 600);
            }
        }

        window.startGame = async () => {
            const name = document.getElementById('p-name').value;
            roomId = document.getElementById('r-id').value;
            if(!name || !roomId) return;
            myId = name + Date.now();
            document.getElementById('login-screen').classList.add('hidden');
            
            const rRef = ref(db, 'rooms/' + roomId);
            const snap = await get(rRef);
            let p = snap.exists() ? snap.val().players : [];
            if(p.length < 4) {
                p.push({id: myId, name, bid:0, tricks:0, hand:[], totalScore:0, roundScores: {}});
                update(rRef, {players: p, status: p.length===4 ? 'waiting' : 'waiting'});
            }
            
            game = new Phaser.Game({ type: Phaser.AUTO, width: window.innerWidth, height: window.innerHeight, parent: 'game-container', scene: MainScene });
            
            onValue(rRef, (s) => {
                const d = s.val();
                if(d && d.status==='waiting' && d.players.length===4 && d.players[0].id===myId) {
                    dealCards(d.players, 1);
                }
            });
        };

        window.dealCards = (players, round) => {
            let deck = []; ['S','H','D','C'].forEach(s => ['2','3','4','5','6','7','8','9','10','J','Q','K','A'].forEach(r => deck.push({s,r})));
            deck.sort(() => Math.random() - 0.5);
            players.forEach((p, i) => { p.hand = deck.slice(i*13, (i+1)*13); p.bid = 0; p.tricks = 0; });
            update(ref(db, 'rooms/'+roomId), { players, status: 'bidding', turn: 0, currentRound: round, currentTrick: [], leadSuit: '' });
        };

        const bDiv = document.getElementById('bid-options');
        for(let i=1; i<=8; i++) {
            const btn = document.createElement('button'); btn.innerText = i;
            btn.onclick = () => {
                const p = [...gameData.players]; p[mySeat].bid = i;
                const nextTurn = (gameData.turn + 1);
                if(nextTurn === 4) {
                    const total = p.reduce((s, pl) => s + pl.bid, 0);
                    // --- CHANGED LOGIC HERE ---
                    if(total < 10) {
                        // 1. Give Points (Bid + 0.1)
                        p.forEach(pl => {
                            if(!pl.roundScores) pl.roundScores = {};
                            pl.roundScores[gameData.currentRound] = pl.bid + 0.1;
                            pl.totalScore = Object.values(pl.roundScores).reduce((a,b) => a+b, 0);
                        });

                        // 2. Check if Game Over (Round 5)
                        if (gameData.currentRound >= 5) {
                            update(ref(db, 'rooms/'+roomId), { players: p, status: 'round_end', currentTrick: [], currentRound: gameData.currentRound });
                        } else {
                            // 3. Move to NEXT Round
                            dealCards(p, gameData.currentRound + 1);
                        }
                        showToast("Total < 10: Bonus Points! Next Round.");
                    } else {
                        update(ref(db, 'rooms/'+roomId), { players: p, status: 'playing', turn: 0 });
                    }
                    // --------------------------
                } else {
                    update(ref(db, 'rooms/'+roomId), { players: p, turn: nextTurn });
                }
            };
            bDiv.appendChild(btn);
        }

        window.showScoreboard = (data) => {
            const screen = document.getElementById('score-screen');
            screen.classList.remove('hidden');
            
            const sorted = [...data.players].sort((a,b) => b.totalScore - a.totalScore);
            
            let html = `<table><tr><th>Rank</th><th>Player</th>`;
            for(let r=1; r<= (data.currentRound || 1); r++) html += `<th>R${r}</th>`;
            html += `<th>Total</th></tr>`;
            
            sorted.forEach((p, idx) => {
                html += `<tr class="${idx===0?'rank-1':''}"><td>${idx+1}</td><td>${p.name}</td>`;
                for(let r=1; r<=(data.currentRound || 1); r++) html += `<td>${p.roundScores ? p.roundScores[r] || '-' : '-'}</td>`;
                html += `<td><b>${p.totalScore.toFixed(1)}</b></td></tr>`;
            });
            document.getElementById('score-content').innerHTML = html + `</table>`;
            
            const isHost = data.players[0].id === myId;
            if(data.currentRound >= 5 && (data.status === 'round_end' || data.players[0].hand.length === 0)) {
                document.getElementById('game-over-controls').classList.remove('hidden');
                document.getElementById('host-next-btn').classList.add('hidden');
            } else if(isHost) {
                document.getElementById('host-next-btn').classList.remove('hidden');
            }
        };

        window.toggleScoreboard = () => {
            if(gameData) showScoreboard(gameData);
            document.getElementById('score-screen').classList.toggle('hidden');
        };

        window.nextRound = () => {
            dealCards(gameData.players, gameData.currentRound + 1);
            document.getElementById('score-screen').classList.add('hidden');
        };

        window.resetWholeGame = () => {
            const p = gameData.players.map(pl => ({...pl, totalScore: 0, roundScores: {}, tricks: 0, bid: 0}));
            dealCards(p, 1);
            document.getElementById('game-over-controls').classList.add('hidden');
            document.getElementById('score-screen').classList.add('hidden');
        };

        function showToast(m) { const n = document.getElementById('notification'); n.innerText = m; n.style.display='block'; setTimeout(()=>n.style.display='none',3000); }
    </script>
</body>
</html>
